# 가장 긴 증가하는 부분 수열 (Longest Increasing Subsequence)

이중 반복문을 사용하여 주어진 숫자의 배열(arr)을 walk through 하면서 `arr[i-1]`과 `arr[i]` 값을 비교하여 증가하는 부분 수열을 찾으며 탐색 한다.

인덱스 i 는 `i=0` 일 때 부분 수열의 개수가 무조건 1이다. 왜냐하면 주어진 숫자의 배열 arr의 부분수열 중 `i=0`인 경우는 첫번째 숫자만 있을 때다. 그렇다면 원소가 1개인 배열의 부분 수열(subseqence)은 무조건 1이 되기 때문이다.

반복문을 순회하며 이전 값(`arr[i-1]`) 과 현재 값(`arr[i]`)을 비교하여 구하고자 하는 dp(LIS의 길이) 배열 값을 갱신한다.

만약 이전 값과 현재 값을 비교하여, 현재 값이 이전 값보다 작다면 갱신 없이 pass하므로 해당 dp[i]는 1이 된다. 오로지 현재 값이 이전 값보다 클 때에만 dp[i]의 값에 1을 더한 값과 비교하여 큰 값으로 dp배열을 갱신 한다.

그 결과 dp의 max값은 부분 수열 중 가장 긴(=원소의 갯수가 가장 많을 때) 값이 된다.
